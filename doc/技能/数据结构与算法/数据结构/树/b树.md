# 一、B树（多叉查找树）
    B树是一种多路搜索树；
  - 根节点至少有两个子女；
  - 每个非根节点所包含的关键字个数j满足：M/2 -1 <= j <= M -1;
  - 除根节点以外的所有节点的度数正好是关键字总数加1，故内部子树个数k满足：m/2 <= k <= m;
  - 所有的叶子节点都位于同一层；


# 二、B-树
    B-树是一种多路搜索树（并不是二叉的）：
  - 定义任意非叶子节点最多只有M个儿子；且M>2;
  - 根节点的儿子数为[2, M]；
  - 除根节点以外的非叶子节点的儿子数为[M/2, M]；
  - 每个节点存放至少M/2-1和至多M-1个关键字（至少2个关键字）；
  - 非叶子节点的关键字个数=指向儿子的指针个数-1；
  - 非叶子节点的关键字：K[1], K[2], ..., K[M-1],q且K[i] < K[i+1]；
  - 非叶子节点的指针：P[1],P[2],...,P[M];其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其他P[i]指向关键字属于（k[i-1],K[i]）的子树；
  - 所有的叶子节点位于同一层；
![blockchain](/resource/images/b-树.JPG "B-树")  
    B-树的搜索，从根节点开始，对节点内的关键字序列进行二分查找，
  - 如果命中则结束；
  - 否则进入查询关键字所属范围的儿子节点；
  - 重复，知道所对应的儿子指针为空，或已经是叶子节点；

    B-树的特性；
  - 关键字集合分布在整棵树中；
  - 任何一个关键字出现且只出现在一个节点中；
  - 搜索有可能在非叶子节点结束；
  - 其搜索性能等价于在关键字全集内做一次二分查找；
  - 自动层次控制；  
  

        由于限制了除根节点意外的非叶子节点，至少含有M/2个儿子，确保了节点的利用率，所以B-树的性能总是等价于二分查找，也即没有B树平衡的问题；
        由于M/2的限制，在插入节点时，如果节点已满，需要将节点分裂为两个各占M/2的节点，删除节点时，需将两个不足M/2的兄弟节点合并；

# 三、B+树（应用于磁盘文件组织数据索引和数据库索引）
    B+树是B-树的辩题，也是一种多路搜索树，其定义基本与B-树相同，除了：
  - 非叶子节点的子数指针与关键字个数相同；
  - 非叶子节点的字数指针P[i]，指向关键字属于[K[i], K[i+1]）的子树（B-树是开区间）;
  - 为所有叶子节点增加一个链指针；
  - 所有关键字都在叶子节点出现；
  ![blockchain](/resource/images/b+树.JPG "B+树")  
    B+树的搜索与B-树也基本相同，区别是B+树只有达到叶子节点才命中（B-树可以在非叶子节点命中），其性能也等价于在关键字全集做一次二分查找；  
    B+的特性：
  - 所有关键字都出现在叶子节点的链表中，且链表中的关键字恰好是有序的；
  - 不可能在非叶子节点命中；
  - 非叶子节点相当于是叶子节点的索引（稀疏索引），叶子节点相当于是存储数据的数据层；
  - 更适合文件索引系统；

# 四、B*树
    B*树是B+树的变体，在B+树的费根和非叶子节点再增加指向兄弟的指针；
![blockchain](/resource/images/b星树.JPG "B*树")  
    B*树定义了非叶子节点关键字个数至少为（2/3)*M，即块的最低使用率为2/3（替代B-、B+树的1/2）；  
    B+树的分裂，当一个节点满时，分配一个新的节点，并将原节点中1/2的数据复制到新节点，最后在父节点中增加新节点的指针；B+树的分裂只影响原节点和父节点，而不会影响兄弟节点，所以它不需要指向兄弟的指针。  
    B*树的分裂，当一个节点满时，如果它的下一个兄弟节点未满，那么将一部分数据移到兄弟节点汇总，再在原节点插入关键字，最后修改父节点中兄弟节点的关键字；如果兄弟也满了，则在原节点与兄弟节点间增加新节点，并各复制1/3的数据到新节点，最后在父节点增加新节点的指针；  
    所以B*树分配新节点的概率要比B+树概率要滴，空间利用率更高。

