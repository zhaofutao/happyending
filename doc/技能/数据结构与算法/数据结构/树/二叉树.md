# 一、二叉查找树（BST）
    B树，即二叉搜索树，特点：
  - 所有非叶子节点之多拥有两个儿子（left和right）；
  - 所有节点存储一个关键字；
  - 非叶子节点的左指针指向翔宇其关键字的子树，右指针指向大于其关键字的子树。  
B树的搜索，从根节点开始，
  - 如果查询的关键字与节点的关键字相等，那么就命中；
  - 如果查询关键字比节点关键字小，就进入做儿子；
  - 如果比节点关键字大，就进入右儿子；
  - 如果左儿子和右儿子的指针为空，则报告找不到相应的关键字。

    如果B树的所有非叶子节点的左右子树的节点数目均保持差不多，那么B树的搜索性能逼近二分查找，但它比连续内存空间的二分查找的优点是，改变B树结构（插入或删除结点）不需要移动大段的内存数据。
    实际使用的B树都是在原B树的基础上加上平衡算法，即平衡二叉树；如何保持B树节点分布均匀的平衡算法是平衡二叉树的关键；

# 二、平衡二叉树（AVL）（windows对进程地址空间的管理）
        平衡二叉树是一颗空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一颗平衡二叉树。在平衡二叉树中，其高度一般都良好的维持在O(logN)，大大降低了操作的时间复杂度。
        调整平衡的基本思想：当在二叉树中插入一个节点时，首先检查是否因插入而破坏了平衡，若破坏，则找出其中的最小不平衡二叉树，在保持二叉排序树特性的情况下，调整最小不平衡子树中节点之间的关系，已达到新的平衡。所谓最小不平衡子树，指离插入节点最近且以平衡因子的绝对值大于1的节点作为根的子树。
        先插入指定节点，记录下当前节点的信息，LH、EH或者RH;
  - 若是左子树高LH，查看其左子树根节点的信息，若是LH，则一次右旋；若是RH，则一次左旋+一次右旋；
  - 若右子树高RH，查看右子树根节点的信息，若是RH，则一次左旋；若是LH，则一次右旋+一次左旋；
  - 调整改变的节点信息；  
        平衡二叉树追求绝对的高度平衡，随着树的高度的增加，动态插入和删除的代价也随之增加；

# 三、红黑树（Red Black Tree， RBTree）（广泛用在C++ STL中）
        红黑树是一种自平衡二叉查找树；
        红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。
        红黑树除了具有二叉搜索树的所有性质以外，还具有以下4点性质：
  - 根节点是很色的；
  - 空节点是黑色的（红黑树中，根节点的paremtn以及所有叶节点IChild、RChild都不指向NULL，而是指向一个定义好的空节点）；
  - 红色节点的父、左子、右子节点都是黑色的；
  - 在任何一颗子树中，每一条从根节点向下走到空节点的路径上包含的黑色节点数量都相同。
  
    红黑树操作代价分析：
  - 查找代价：由于红黑树的性质（最长路径长度不超过最短路径长度的2倍），可以说明红黑树虽然不像AVL一样是严格平衡的，但平衡性能还是要比二叉树要好，其查找代价基本维持在O(logN)左右，但在最差的情况下，比AVL要略逊色一些；
  - 插入代价：红黑树插入节点时，需要旋转操作和变色操作，但由于只需要保证红黑树基本平衡就可以了，因此插入节点最多只需要2次旋转（这一点和AVL的插入操作一样），虽然变色操作需要O(logN)，但变色操作十分简单，代价很小；
  - 删除代价：红黑树的删除操作代价要比AVL要好的多，删除一个节点最多只需要3次旋转操作；
    红黑树效率总结：
  - 查找效率最好情况下时间复杂度为O(logN)，但在最坏情况下比AVL要差一些，但也远远好于二叉树。
  - 插入和删除操作改变树的平衡性的概率要远远效率AVL，因此需要的旋转操作的可能性药效，而且一旦需要旋转，插入一个节点最多只需要旋转2次、删除最多只需要旋转3次（小于AVL的删除操作所需要的旋转次数）。

