# 一、垃圾回收基本概念
        垃圾是指没有任何引用的一个对象或者多个对象（多个对象互相引用，但是没有一个与主对象挂钩）；
        内存泄露：内存泄露是指有的内存地址太过碎片化而无法被利用；
        内存溢出：内存溢出是指内存已经装满了，无法再装下更多的对象了；
        垃圾回收Garbage Collection通常被称为GC，是指对垃圾内存主动进行回收。

# 二、垃圾定位
    常用的定位垃圾方式：
  - 引用计数(Reference Count)  
  每当一块内存被一个对象引用，那么计数就+1，当没有对象指向时，计数为0，就表示这块内存可以被回收了。
  引用计数器没办法解决垃圾之间引用的情况，当几块内存都没有外部引用，但是这几块内存之间相互引用的时候，这几块内存也应该视为来及，但是计数器却不为0。
  - 根可达算法(Root Searching)  
  当程序运行时，将根对象取出，由根对象触发往下查找，最终找不到的对象，都视为无法由根对象找到，也就是垃圾。
  根对象主要包含JVM Stack、Native Method Stack、Run-time constant pool、方法区里的静态应用、Clazz等。

# 三、常见的垃圾回收算法
    主要包含以下三种：
  - 标记删除(masrk sweep)
  将所有的垃圾标记出来，然后直接清除掉。但是这种方式有一个严重的问题，会使得内存变得碎片化；
  - 拷贝算法(copying)  
  将内存平分为两块，在使用的过程中只能在其中一块内存里创建对象，当需要垃圾回收时，将有对象的内存全部复制到另一边，并且将当前区域全部清除，这种方式解决了内存碎片化的问题，但是却浪费了空间，每次只能利用一半内存。
  - 标记压缩(mark compact)  
  在清理垃圾的同时，将同类型的内存空间放置在一起，也就是说在清理的同时进行空间整理，并且多线程时还需要进行线程同步，这种方式的缺点是效率偏低。

    常见的垃圾回收算法就是这3种或者这3中方式的组合；

# 四、JVM内存分代模型
    JVM的内存模型是由垃圾回收器所决定的，一般分为分代模型和不分代模型；
    分代模型在逻辑上分代，在物理层面也就是内存中也是分成了new（新生代）和old（老年代）两大区域。
    新生代又分为eden（伊甸园）、survivor1和survivor2。新生代的对象有两大特定：大量产生、大量回收（大多数情况下，一次回收90%的对象）。所以根据新生代采用的算法是拷贝算法。
    老年代为了保证内存的连续性，往往采用标记压缩算法。
    新生代和老年代的比例默认是1:2，eden、survivor1和survivor2的默认比例是8:1:1；

# 五、对象创建到回收过程
  - 当我们new出一个对象，JVM会首先尝试往栈上分配，如果能够分配的下，就分配到栈上。分配到栈上的好处是不需要GC管理，什么时候不需要此对象了，将对象出栈就可以了。分配到栈上的对象要求：1、对象比较小，因为栈的空间不够大；2、对象比较简单；
  - 如果栈上分配不下，我们就判断这个对象是不是够大，如果足够大就直接放在老年代区，在老年代区的对象经过一次全量垃圾回收FGC后，才有可能被回收掉；
  - 如果栈上分配不下并且对象不大，就会判断对象能否被存在线程本地分配缓冲区TLAB(Thread Local Allocation Buffer)，但是不管放不放得下，都是放在新生代区的伊甸区，但是因为堆是共享的，多个线程可以同时创建对象就可能会争夺同一块内存区域，所以为了保证线程安全，伊甸区又被分配成一个个线程本地分配缓冲区，这个线程本地缓冲区是线程私有的，避免了多线程环境下使用同步技术带来的性能损耗。

