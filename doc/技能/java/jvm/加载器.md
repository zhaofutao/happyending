# 一、类加载
    类加载分为三个步骤：加载、连接、初始化；

## 1. 加载
        类加载指的是将class文件读入内存，并为之创建一个java.lang.Class对象，即程序中使用任何类时，系统都会为之简历一个java.lang.Class对象，系统中所有的类都是java.lang.Class的实例。
        类的加载由类加载器完成，JVM提供的类加载器叫做系统类加载器，此外还可以通过继承ClassLoader基类来自定义类加载器。
        通常可以用如下几种方式加载累的二进制数据：  
  - 从本地文件系统加载class文件；
  - 从jar包中加载class文件；
  - 通过网络加载class文件；
  - 把一个Java源文件动态编译并执行加载；

## 2. 连接
    连接阶段负责把类的二进制数据合并到JRE中，其又可分为如下三个阶段：
  - 验证：确保加载的类信息符合JVM规范，无安全方面的问题；
  - 准备：为类的静态字段分配内存，并设置初始值；
  - 解析：将类的二进制数据中的符号引用替换成直接引用；

## 3. 初始化
        该阶段主要是对静态字段进行初始化，在Java类中对静态字段指定初始值有两种方式：
  - 声明时即指定初始值，如static int a = 5;
  - 使用静态代码块为静态字段指定初始值，如static { b = 5;}

        JVM初始化一个类包含如下几个步骤：
  - 假如这个类还没有被加载和连接，则程序先加载并连接该类；
  - 假如该类的直接父类还没有被初始化，则先初始化其父类；
  - 假如类中有初始化语句，则系统依次执行这些初始化语句；

    类初始化的时机（对类进行主动引用时）
  - 创建类的实例时（new、反射、反序列化）；
  - 调用某个类的静态方法时；
  - 使用某个类或者接口的静态字段或对该字段赋值时；
  - 使用反射来强制创建某个类或接口对应的java.lang.Class对象，如Class.forName("Person");
  - 初始化某个类的子类时，此时该子类的所有父类都会被初始化；
  - 直接使用java.exe运行某个主类时；

# 二、类加载器及加载机制
![blockchain](/resource/images/类加载器.png "类加载器")  
    类加载器负责将class文件读入内存，并为之生成对应的java.lang.Class对象。
## 1. Java9之前类加载器
    当JVM启动时，会形成有3个类加载器组成的初始类加载器层次结构；
  - Bootstrap ClassLoader：根类（或叫启动、引导类加载器）加载器；  
    它负责加载Java的核心类（如String、System等），它比较特殊，因为它是由原生C++代码实现的，并不是java.lang.ClassLoader的子类；
  - Extension ClassLoader：扩展类加载器；
    它负责加载JRE的扩展目录中JAR包的类，我们可以通过把自己开发的类打包成jar文件放入扩展目录来为Java扩展核心类以为的新功能。
  - System ClassLoader (或Application ClassLoader)：系统类加载器
    它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性、或CLASSPATH环境变量所指定的jar包或类路径。

![blockchain](/resource/images/java8类加载机制.png "Java8类加载机制")  
    JVM的类加载机制主要有以下三种：
  - 全盘负责：当一个类加载器加载某个Class时，该Class所依赖和引用的其他Class也将由该类加载器负责载入，除非显示的使用另外一个类加载器来载入。
  - 双亲委派：当一个类加载器收到了类加载请求，它会把这个请求委派给父类加载器去完成，一次递归，因此所有的加载请求最终都被传送到顶层的启动类加载器中。只有在父类加载器无法加载该类时子类才尝试从自己累的路径中加载该类。
  - 缓存机制：缓存机制会保证所有加载过的Class都会被缓存，当程序中需要使用用某个类时，类加载器先从缓存中搜寻该类，若搜寻不到将读取该类的二进制数据，并转换成Class对象存入缓冲区中。这就是为什么修改了Class后需重启JVM才能生效的原因。

## 2. Java9类加载机制
![blockchain](/resource/images/java9类加载机制.png "Java9类加载器")  

        jdk9保持了三级分层类加载器架构以实现向后兼容。但是，从模块系统加载类的方式有一些变化，且新增Platform ClassLoader：平台类加载器，用于加载一些平台相关的模块。双亲是BootClassLoader。
        jdk9不再支持扩展机制，但是它将扩展类加载器保留在名为平台类加载器的新名称下。

        jdk9中的类加载机制有所改变，三个内置的类加载器一起协作来加载类。
        当应用程序类加载器需要加载类是，它将搜索定义到所有类加载器的模块，如果有合适的模块定义在这些类加载器中，则该类加载器将加载类，这意味着应用程序类加载器可以委托给引导类加载器和平台类加载器。如果在为这些类加载器定义的命名模块中找不到类，则应用程序类加载器将委托给其父类，即平台类加载器。